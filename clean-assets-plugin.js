const HtmlWebpackPlugin = require('html-webpack-plugin');
const PLUGIN_NAME = 'CleanAssetsPlugin';

class CleanAssetsPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
      HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tapAsync(PLUGIN_NAME, (data, cb) => {
        const pageKey = data.plugin.options.nextData.page;

        // Regex to select only the page-specific .js file and the _app.js file
        const pageSpecificFilesRegex = new RegExp('((/_app|' + pageKey + ').js)$');

        // Correct the URL and add a Next-related ID
        data.assetTags.scripts = data.assetTags.scripts
          .filter(script => script.attributes.src.match(pageSpecificFilesRegex))
          .map(script => ({
            ...script,
            attributes: {
              src: script.attributes.src.replace('../static', '/_next/static'),
              'data-next-page': script.attributes.src.match(pageSpecificFilesRegex)[1].replace('.js', ''),
              defer: ''
            }
          }));

        cb(null, data);
      });

      HtmlWebpackPlugin.getHooks(compilation).alterAssetTagGroups.tapAsync(PLUGIN_NAME, (data, cb) => {
        const pageKey = data.plugin.options.nextData.page;

        // Get the build manifest generated by NextJS
        // It contains the chunks linked with each page
        const buildManifest = JSON.parse(compilation.assets['build-manifest.json']['_value']);

        // Gather chunk files from the build manifest, removing duplicates
        const chunkFiles = [
          ...new Set([
            ...buildManifest.pages['/_polyfills'],
            ...buildManifest.pages[pageKey],
            ...buildManifest.pages['/_app']
          ])
        ];

        // Format chunks needed by the page
        const chunks = chunkFiles.map(src => ({
          tagName: 'script',
          voidTag: false,
          // Attributes are different for polyfills
          attributes: src.includes('polyfills-')
            ? {
                src: '/_next/' + src,
                nomodule: ''
              }
            : {
                src: '/_next/' + src,
                defer: ''
              }
        }));

        // Add chunks to body tags
        data.bodyTags = [...data.bodyTags, ...chunks];

        // Also add these chunks in the header preload information
        const jsFilesToPreload = data.bodyTags.map(script => ({
          tagName: 'link',
          voidTag: false,
          attributes: {
            rel: 'preload',
            href: script.attributes.src,
            as: 'script'
          }
        }));

        data.headTags = [...data.headTags, ...jsFilesToPreload];

        cb(null, data);
      });

      HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapAsync(PLUGIN_NAME, (data, cb) => {
        // Add the next-head-count meta tag, which is required otherwise Next crashes
        // We can't use the "meta" config of HtmlWebpackPlugin because it isn't a standard meta tag
        data.headTags = [
          ...data.headTags,
          {
            tagName: 'meta',
            voidTag: true,
            attributes: {
              name: 'next-head-count',
              content: 1
            }
          }
        ];

        // Add the nextData as a JSON at the end of the file
        // This is required for Next to work correctly
        data.bodyTags = [
          ...data.bodyTags,
          {
            tagName: 'script',
            attributes: {
              id: '__NEXT_DATA__',
              type: 'application/json'
            },
            innerHTML: JSON.stringify(data.plugin.options.nextData)
          }
        ];

        cb(null, data);
      });
    });
  }
}

module.exports = CleanAssetsPlugin;
